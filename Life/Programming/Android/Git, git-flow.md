**Git** - распределенная система контроля версия, что означает, что он позволяет хранить целиком весь репозиторий со всей его историей и файлами локально у каждого пользователя, а не получать какую-то маленькую часть репозитория. 

Из-за этого есть существуют некоторые особенности - например, гит хранит все добавленные когда-либо в коммиты файлы, даже после их удаления в следующих коммитах, и при скачивании репозитория мы скачиваем все эти файлы и храним локально. Коммит является слепком всего проекта в конкретный период времени. Гит конечно же не просто копирует все файлы для каждого коммита, а оптимизирует хранение с помощью диффов и сжатия. 
![[Pasted image 20240215173838.png]]
Также это означает, что после коммита уже не возможно потерять какие-либо изменения, что позволяет не боясь экперементировать.
![[Pasted image 20240215170059.png]]


Единица информации в гите - это объект, сохраняемый по хэш-сумме, содержащий все изменения.
У Git есть три основных состояния, в которых могут находиться ваши файлы: _изменён_ (modified), _индексирован_ (staged) и _зафиксирован_ (committed):

- К изменённым относятся файлы, которые поменялись, но ещё не были зафиксированы.
    
- Индексированный — это изменённый файл в его текущей версии, отмеченный для включения в следующий коммит. Эта стадия нужна для того, чтобы определить какие именно файлы попадут в коммит
    
- Зафиксированный значит, что файл уже сохранён в вашей локальной базе.

Выделяют 3 области в гит-проекте: **рабочая область, индекс и каталог Git**.

**Рабочая копия** является снимком одной версии проекта. Эти файлы извлекаются из сжатой базы данных в каталоге Git и помещаются на диск, для того чтобы их можно было использовать или редактировать.

**Область индексирования** — это файл, обычно находящийся в каталоге Git, в нём содержится информация о том, что попадёт в следующий коммит. Её техническое название на языке Git — «индекс», но фраза «область индексирования» также работает.

**Каталог Git** — это то место, где Git хранит метаданные и базу объектов вашего проекта. Это самая важная часть Git и это та часть, которая копируется при _клонировании_ репозитория с другого компьютера.


### Основные команды
**git init** - Позволяет превратить директорию в гит-проект. Нужен для инициализации репозитория гит
**git clone ::url**  - Позволяет скачать и инициализировать существующий репозиторий со всей его историей.
**git add ::files** - Добавляет выбранные файлы к область индексирование (в индекс).
**git commit -m ::message** - Добавляет все файлы, находящиеся в области индексирование в каталог(базу данных) Git, в репозиторий.
**git commit -am ::mesage** - -a автоматически добавляет все измененные файлы в область индексирования перед коммитом. Позволяет пропустить git add, но только для тех файлов, которые уже были закоммичены ранее.
**git commit --amend** - Редактировать последний локальный коммит. Можно изменить message в коммите, редактировать, добавлять любые файлы и при этом не создастся новый коммит, а перезапишется последний, но измениться его SHA-1. *git commit --amend --no-edit* - не редактировать сообщения последнего коммита.
**git status** - команда для получения информации о текущем состоянии гит-репозитория. 
```console
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working tree clean
```
**git stash** - Команда, которая позволяет сохранить текущие изменения в "стэш" и вернуться в состояние, совпадающие с последним коммитом в ветке. В последствии можно достать эти изменения из стэша и применить даже поверх другого коммита. (В Android Studio есть идентичная механика "Shelve changes", но она не связана с гитом, а только с IDE).
```console
$ git stash push // сохранить текущие изменения и вернуться к HEAD коммиту 
$ git stash list // показать список сохраненных в стэше изменений
$ git stash show // просмотреть конкретное изменение стэша
$ git stash apply // применить изменение из стэша поверх текущего коммита
```

**git fetch** - команда, которая подтягивает из удаленного репозитория все изменения, которые произошли с ним с момента git clone или предыдущего git fetch. git fetch не сливает удаленные ветки в локальные, это нужно делать самостоятельно.
**git pull** - команда, которая подтягивает удаленную ветку и сливает ее с локальной, если в репозитории настроено отслеживание удаленной ветки. git fetch, как правило, выполняет сначала git fetch, а потом git merge, но можно настроить, чтобы гит выполнял rebase:
```console 
git config --global pull.rebase "true"
```
**git push** - команда, позволяющая отправлять свои изменения на удаленный сервер. git push ##remote-name ##branch-name. Например, чтобы отправить изменения в master нужно выполнить следующую команду 
```console 
$ git push origin master
```

Это команда срабатывает только в том случае, если у вас есть права на запись и никто не пушил изменения, которых у вас нет в локальном репозитории. Если кто-то запушил, то сначала нужно будет подтянуть изменения и слить вместе с локальными.
Чтобы все остальные могли видеть новую ветку `main`, вам нужно отправить её в общий репозиторий. Это делает переименованную ветку доступной в удалённом репозитории.

```console
$ git push --set-upstream origin main
```

**git branch** - команда, которая позволяет управлять ветками в гите. 

```console
$ git branch branch_name // создать новую ветку
$ git branch // вывести список имеющихся веток
$ git branch -v // вывести список веток с последними их коммитами
$ git branch --move bad_branch_name corrected_branch_name // переименование ветки
$ git branch -d branch_name // удалить ветку
```

**git checkout #branch_name** - Переключиться на ветку.
```console
$ git checkout -b branch_name // создать новую ветку и переключится на нее 
```

**git merge #branch_name** - Команда, с помощью которой можно влить branch_name ветку в текущую ветку. Берется 2 конечные точки текущей ветки и branch_name и сливаются. При этом создастся коммит с 2 родителями: последний коммит текущей ветки и последний коммит влитой ветки. Если в текущей ветке нет других изменений и изменения сливаемой ветки делались поверх последнего коммита, то применяется метод fast-forward. Это означает, что указатель ветки просто сдвинется на коммит из сливаемой ветки, потому что нет никаких разнонаправленных изменений.

При слиянии могут появится конфликты, когда в 2 ветках были изменены одни и те же файлы в одних и тех же местах. Тогда гит не может чисто слить 2 ветки и приходится разрешать конфликты вручную. В такой ситуации гит создает маркеры

```html
<<<<<<< HEAD:index.html
<div id="footer">contact : email.support@github.com</div>
=======
<div id="footer">
 please contact us at support@github.com
</div>
>>>>>>> iss53:index.html
```

То, что вышел ===== - изменения из текущей ветки, то, что ниже - из ветки, которую пытаются слить. 
После разрешения конфликта, нужно добавить измененные файлы, используя git add и git commit.
*Лучше всего мерджить через IDE*
При мердже история коммитов выглядит сумбурно и нелинейно, если есть необходимость в линейной истории коммитов, нужно использовать git rebase.

**git rebase #branch_name**  -  Команда, с помощью которой все коммиты текущей ветки поочередно применяются поверх branch_name ветки в том порядке, в котором они были сделаны и указатель текущей ветки перемещается на последний коммит из текущей ветки. То есть текущая ветка будет содержать в себе все изменения из branch_name, поверх которой будут записаны уникальные коммиты. Далее можно переключиться на ветку branch_name и сделать git merge fast-forward, потому что не будет никаких конфликтов, гит просто перенесет их поверх ветки branch_name.

```console
$ git rebase --onto master server client // В этой команде говорится: «Переключись на ветку `client`, найди изменения относительно ветки `server` и примени их для ветки `master`»
```

При использование git rebase теряется история слияния веток и тяжелее отслеживать когда что-то сломалось, если что-то неправильно слили.

**git cherry-pick #commit** - берет изменения из commit и пытается повторно применить эти изменения поверх текущего HEAD. 

**git revert #commit** - создает коммит, противоположный указанному, отменяя все изменения указанного кмомита. 
### Git branching: ветки, теги, HEAD, навигация по гиту

В отличие от других СКВ, в гите - работа с ветками является легковесной и желательной, так как создание, переключение между ветками происходит очень быстро.

При создании ветки просто создается новый указатель на коммит. Git определяет на какой ветке мы сейчас находимся с помощью указателя **HEAD**.
Для перемещения по коммитам также можно использовать относительные ссылки:
```console
$ git <branch_name/HEAD/commit_name>^ // переместиться на родительский коммит выбранной ветки, HEAD, коммита
$ git branch_name/HEAD/commit_name>~N // переместиться на N элементов вверх выбранной ветки, HEAD, коммита
```
Ветка по своей сути - это просто перемещаемый указатель, который всегда указывает на самый последний коммит.

При переключении веток - Git восстанавливает рабочий каталог таким, какой он был при последнем коммите в этой ветке. Git удаляет, изменяет и перемещает файлы автоматически.

**Тэг** - это неперемещаемый (в отличии от веток) указатель на отдельный коммит. Обычно он проставляется после выпуска релизной версии приложения. При переключении на тэг мы входим в состояние Detached HEAD, что означает, что мы не находимся ни на какой ветке и дальнейшие коммиты в таком состоянии могут быть утеряны, так как к коммитам можно будет обращаться только по его хешу. По умолчанию git push не отправляет тэги в удаленный репозиторий, тэг нужно пушить отдельно командой *git push origin #tag_name*.
```console 
$ git tag // посмотреть список имеющихся тегов
$ git tag <tag_name> // создать легковесный тэг (обычный указатель на коммит)
$ git tag -a <tag_name> -m <message> // создать аннотированный тэг, который хранится как объект, имеет контрольную сумму, содержат имя автора, его e-mail и дату создания, имеют комментарий
$ git push origin <tag_name> // отправить тэг в удаленный репозиторий
$ git push origin --tags // отправить все тэги в удаленный репозиторий
$ git tag -d <tag_name> // удалить тэг
$ git checkout <tag_name> // переключиться на тэг
```

### Изменения истории, git-config, force, reflog

**git rebase -i** - Запускает интерактивный режим перебазирования, с помощью которого можно изменять все историю коммитов. Изменение истории коммитов можно выполнять только для локальных, еще не отправленных в удаленный репозиторий изменений.

**git push --force** - Отправляет изменения в удаленный репозиторий и игнорируется проверка коммитов. При необходимости будет выполнена перезапись истории и удаленная ветка будет выглядеть в точности, как локальная. Эта команда может удалить коммиты других людей в удаленном репозитории.

**git push --force-with-lease** - Дополнительно проверяет наличие новых коммитов в репозитории и запрещает пушить, если кто-то другой уже закоммитил в ветку.  Если, например, была использована команда git commit --amend, и никто не делал новых коммитов, эта команда перезапишет историю удаленного репозитория.

Приоритет при коммитах снизу - вверх.
```console
$ git config --global user.name "John Doe" //установка имени для гита для текущего пользователя
$ git config --global user.email johndoe@example.com //установка электроной почты для гита для текущего пользователя
$ git config --system user.name "John Doe" //установка имени для гита для всей системы
$ git config user.name "John Doe" //установка имени для гита для текущего проекта
```


**git reflog** - Команда, которая выводит все измененения, происходившие в репозитории: переключение веток, коммиты, перезапись коммитов, удаление веток и т.д.
### Работа с удаленным репозиторием, GitFlow

**GitFlow** - набор правил для работы с гитом в команде с несколькими людьми. 
Существуют 2 постоянные ветки:
*master* - ветка, в которой находится самый стабильный код. Обычно изменения туда вносятся после релиза или прямо перед релизом и из нее уже публикуют новую версию.
*development* - ветка, в которой находится код для следующего релиза, реализованные фичи. Из нее собирается release candidat и от нее ответвляются фича ветки.

Также есть временные ветки:
*Feature-branch* - ветка, в которой ведется разработка конкретной фичи. После завершения разработки и тестирования эта ветка вливается в development, с помощью pull-request'а, а за тем удаляется.
*Release-branch* - ветка, которая создается из development в момент фича-фриза (перед релизом) для исправления доработок, фиксов. Из этой ветки собирается release candidat. В релиз бранч нельзя вливать новые фичи. После регрессионного и смоук-тестирования ветка вливается в master и в development. Релиз публикуется и ветка удаляется.
*Hotfix-branch* - ветка, необходимая для исправления багов в релизе. Порождается от master, после исправления вливает в master и в development, после чего удаляется.
*Bugfix-branch* - ветка, необходимая для исправления дефектов. Порождается от development и вливается в development. Данная ветка нужна, если нашли дефект, но feature-branch уже влита и удалена.