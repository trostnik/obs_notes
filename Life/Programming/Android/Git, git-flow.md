**Git** - распределенная система контроля версия, что означает, что он позволяет хранить целиком весь репозиторий со всей его историей и файлами локально у каждого пользователя, а не получать какую-то маленькую часть репозитория. 

Из-за этого есть существуют некоторые особенности - например, гит хранит все добавленные когда-либо в коммиты файлы, даже после их удаления в следующих коммитах, и при скачивании репозитория мы скачиваем все эти файлы и храним локально. Коммит является слепком всего проекта в конкретный период времени. Гит конечно же не просто копирует все файлы для каждого коммита, а оптимизирует хранение с помощью диффов и сжатия. 
![[Pasted image 20240215173838.png]]
Также это означает, что после коммита уже не возможно потерять какие-либо изменения, что позволяет не боясь экперементировать.
![[Pasted image 20240215170059.png]]


Единица информации в гите - это объект, сохраняемый по хэш-сумме, содержащий все изменения.
У Git есть три основных состояния, в которых могут находиться ваши файлы: _изменён_ (modified), _индексирован_ (staged) и _зафиксирован_ (committed):

- К изменённым относятся файлы, которые поменялись, но ещё не были зафиксированы.
    
- Индексированный — это изменённый файл в его текущей версии, отмеченный для включения в следующий коммит. Эта стадия нужна для того, чтобы определить какие именно файлы попадут в коммит
    
- Зафиксированный значит, что файл уже сохранён в вашей локальной базе.

Выделяют 3 области в гит-проекте: **рабочая область, индекс и каталог Git**.

**Рабочая копия** является снимком одной версии проекта. Эти файлы извлекаются из сжатой базы данных в каталоге Git и помещаются на диск, для того чтобы их можно было использовать или редактировать.

**Область индексирования** — это файл, обычно находящийся в каталоге Git, в нём содержится информация о том, что попадёт в следующий коммит. Её техническое название на языке Git — «индекс», но фраза «область индексирования» также работает.

**Каталог Git** — это то место, где Git хранит метаданные и базу объектов вашего проекта. Это самая важная часть Git и это та часть, которая копируется при _клонировании_ репозитория с другого компьютера.


### Основные команды
**git init** - Позволяет превратить директорию в гит-проект. Нужен для инициализации репозитория гит
**git clone ::url**  - Позволяет скачать и инициализировать существующий репозиторий со всей его историей.
**git add ::files** - Добавляет выбранные файлы к область индексирование (в индекс).
**git commit -m ::message** - Добавляет все файлы, находящиеся в области индексирование в каталог(базу данных) Git, в репозиторий.
**git commit -am ::mesage** - -a автоматически добавляет все измененные файлы в область индексирования перед коммитом. Позволяет пропустить git add, но только для тех файлов, которые уже были закоммичены ранее.
**git commit --amend** - Редактировать последний локальный коммит. Можно изменить message в коммите, редактировать, добавлять любые файлы и при этом не создастся новый коммит, а перезапишется последний.
**git status** - команда для получения информации о текущем состоянии гит-репозитория. 
```console
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working tree clean
```
**git stash** - Команда, которая позволяет сохранить текущие изменения в "стэш" и вернуться в состояние, совпадающие с последним коммитом в ветке. В последствии можно достать эти изменения из стэша и применить даже поверх другого коммита. (В Android Studio есть идентичная механика "Shelve changes", но она не связана с гитом, а только с IDE).
```console
$ git stash push // сохранить текущие изменения и вернуться к HEAD коммиту 
$ git stash list // показать список сохраненных в стэше изменений
$ git stash show // просмотреть конкретное изменение стэша
$ git stash apply // применить изменение из стэша поверх текущего коммита
```

**git fetch** - команда, которая подтягивает из удаленного репозитория все изменения, которые произошли с ним с момента git clone или предыдущего git fetch. git fetch не сливает удаленные ветки в локальные, это нужно делать самостоятельно.
**git pull** - команда, которая подтягивает удаленную ветку и сливает ее с локальной, если в репозитории настроено отслеживание удаленной ветки. git fetch, как правило, выполняет сначала git fetch, а потом git merge, но можно настроить, чтобы гит выполнял rebase:
```console 
git config --global pull.rebase "true"
```
**git push** - команда, позволяющая отправлять свои изменения на удаленный сервер. git push ##remote-name ##branch-name. Например, чтобы отправить изменения в master нужно выполнить следующую команду 
```console 
$ git push origin master
```

Это команда срабатывает только в том случае, если у вас есть права на запись и никто не пушил изменения, которых у вас нет в локальном репозитории. Если кто-то запушил, то сначала нужно будет подтянуть изменения и слить вместе с локальными.
Чтобы все остальные могли видеть новую ветку `main`, вам нужно отправить её в общий репозиторий. Это делает переименованную ветку доступной в удалённом репозитории.

```console
$ git push --set-upstream origin main
```

**git branch** - команда, которая позволяет управлять ветками в гите. 

```console
$ git branch branch_name // создать новую ветку
$ git branch // вывести список имеющихся веток
$ git branch -v // вывести список веток с последними их коммитами
$ git branch --move bad_branch_name corrected_branch_name // переименование ветки
$ git branch -d branch_name // удалить ветку
```

**git checkout #branch_name** - Переключиться на ветку.
```console
$ git checkout -b branch_name // создать новую ветку и переключится на нее 
```

**git merge #branch_name** - Команда, с помощью которой можно влить branch_name ветку в текущую ветку. При этом создастся коммит с 2 родителями: последний коммит текущей ветки и последний коммит влитой ветки. Если в текущей ветке нет других изменений и изменения сливаемой ветки делались поверх последнего коммита, то применяется метод fast-forward. Это означает, что указатель ветки просто сдвинется на коммит из сливаемой ветки, потому что нет никаких разнонаправленных изменений.

При слиянии могут появится конфликты, когда в 2 ветках были изменены одни и те же файлы в одних и тех же местах. Тогда гит не может чисто слить 2 ветки и приходится разрешать конфликты вручную. В такой ситуации гит создает маркеры

```html
<<<<<<< HEAD:index.html
<div id="footer">contact : email.support@github.com</div>
=======
<div id="footer">
 please contact us at support@github.com
</div>
>>>>>>> iss53:index.html
```

То, что вышел ===== - изменения из текущей ветки, то, что ниже - из ветки, которую пытаются слить. 
После разрешения конфликта, нужно добавить измененные файлы, используя git add и git commit.
*Лучше всего мерджить через IDE*

### Git branching: ветки, теги, HEAD, навигация по гиту

В отличие от других СКВ, в гите - работа с ветками является легковесной и желательной, так как создание, переключение между ветками происходит очень быстро.

При создании ветки просто создается новый указатель на коммит. Git определяет на какой ветке мы сейчас находимся с помощью указателя HEAD.
Ветка по своей сути - это просто перемещаемый указатель, который всегда указывает на самый последний коммит.

При переключении веток - Git восстанавливает рабочий каталог таким, какой он был при последнем коммите в этой ветке. Git удаляет, изменяет и перемещает файлы автоматически.

### Изменения истории, git-config, force, reflog, merge vs rebase vs cherry-pick

Приоритет при коммитах снизу - вверх.
```console
$ git config --global user.name "John Doe" //установка имени для гита для текущего пользователя
$ git config --global user.email johndoe@example.com //установка электроной почты для гита для текущего пользователя
$ git config --system user.name "John Doe" //установка имени для гита для всей системы
$ git config user.name "John Doe" //установка имени для гита для текущего проекта
```

### Работа с удаленным репозиторием, GitFlow